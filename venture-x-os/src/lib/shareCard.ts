import { DecisionCard, ConfidenceLevel } from './types';

/**
 * Generate a shareable card image from a decision
 */
export async function generateShareCard(
  card: DecisionCard,
  options: {
    width?: number;
    height?: number;
    theme?: 'light' | 'dark';
  } = {}
): Promise<Blob> {
  const { width = 600, height = 400, theme = 'light' } = options;

  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext('2d')!;

  // Colors
  const colors = theme === 'dark'
    ? {
        bg: '#0f172a',
        cardBg: '#1e293b',
        text: '#f8fafc',
        textSecondary: '#94a3b8',
        accent: '#33a3ff',
        border: '#334155',
      }
    : {
        bg: '#f8fafc',
        cardBg: '#ffffff',
        text: '#0f172a',
        textSecondary: '#64748b',
        accent: '#146de1',
        border: '#e2e8f0',
      };

  // Background
  ctx.fillStyle = colors.bg;
  ctx.fillRect(0, 0, width, height);

  // Card background with rounded corners
  const cardMargin = 24;
  const cardWidth = width - cardMargin * 2;
  const cardHeight = height - cardMargin * 2;
  const cardRadius = 16;

  ctx.fillStyle = colors.cardBg;
  roundRect(ctx, cardMargin, cardMargin, cardWidth, cardHeight, cardRadius);
  ctx.fill();

  // Border
  ctx.strokeStyle = colors.border;
  ctx.lineWidth = 1;
  roundRect(ctx, cardMargin, cardMargin, cardWidth, cardHeight, cardRadius);
  ctx.stroke();

  // Header section
  const headerY = 48;
  
  // Type icon/emoji
  const typeEmoji = getTypeEmoji(card.type);
  ctx.font = '32px Arial';
  ctx.fillText(typeEmoji, 48, headerY + 8);

  // Title
  ctx.font = 'bold 24px Inter, sans-serif';
  ctx.fillStyle = colors.text;
  ctx.fillText(card.title, 96, headerY);

  // Confidence badge
  const confidenceColor = getConfidenceColor(card.confidence);
  ctx.fillStyle = confidenceColor;
  ctx.font = 'bold 12px Inter, sans-serif';
  const badgeX = width - 100;
  ctx.fillRect(badgeX, headerY - 18, 60, 24);
  ctx.fillStyle = '#ffffff';
  ctx.fillText(card.confidence, badgeX + 10, headerY - 2);

  // Summary
  ctx.font = '16px Inter, sans-serif';
  ctx.fillStyle = colors.textSecondary;
  ctx.fillText(card.summary, 48, headerY + 36);

  // Divider
  ctx.strokeStyle = colors.border;
  ctx.beginPath();
  ctx.moveTo(48, headerY + 60);
  ctx.lineTo(width - 48, headerY + 60);
  ctx.stroke();

  // Key numbers
  const numbersY = headerY + 100;
  const numberWidth = (cardWidth - 48) / Math.min(card.keyNumbers.length, 4);

  card.keyNumbers.slice(0, 4).forEach((num, idx) => {
    const x = 48 + idx * numberWidth;
    
    // Value
    ctx.font = 'bold 28px Inter, sans-serif';
    ctx.fillStyle = num.highlight ? colors.accent : colors.text;
    ctx.fillText(num.value, x, numbersY);

    // Label
    ctx.font = '12px Inter, sans-serif';
    ctx.fillStyle = colors.textSecondary;
    ctx.fillText(num.label, x, numbersY + 24);
  });

  // Footer
  const footerY = height - 48;
  ctx.font = '12px Inter, sans-serif';
  ctx.fillStyle = colors.textSecondary;
  ctx.fillText('Generated by Venture X OS', 48, footerY);

  // Timestamp
  const timestamp = new Date(card.createdAt).toLocaleDateString();
  const timestampWidth = ctx.measureText(timestamp).width;
  ctx.fillText(timestamp, width - 48 - timestampWidth, footerY);

  // Convert to blob
  return new Promise((resolve) => {
    canvas.toBlob((blob) => {
      resolve(blob!);
    }, 'image/png');
  });
}

/**
 * Download the share card as a PNG
 */
export async function downloadShareCard(card: DecisionCard, theme: 'light' | 'dark' = 'light'): Promise<void> {
  const blob = await generateShareCard(card, { theme });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `venture-x-decision-${card.id}.png`;
  a.click();
  URL.revokeObjectURL(url);
}

/**
 * Copy share card to clipboard
 */
export async function copyShareCardToClipboard(card: DecisionCard, theme: 'light' | 'dark' = 'light'): Promise<boolean> {
  try {
    const blob = await generateShareCard(card, { theme });
    await navigator.clipboard.write([
      new ClipboardItem({
        'image/png': blob,
      }),
    ]);
    return true;
  } catch (error) {
    console.error('Failed to copy to clipboard:', error);
    return false;
  }
}

/**
 * Generate text summary for sharing
 */
export function generateShareText(card: DecisionCard): string {
  const lines = [
    `üìä ${card.title}`,
    ``,
    card.summary,
    ``,
    `Key Numbers:`,
    ...card.keyNumbers.map((n) => `‚Ä¢ ${n.label}: ${n.value}`),
    ``,
    `Confidence: ${card.confidence}`,
    ``,
    `Generated by Venture X OS`,
  ];

  return lines.join('\n');
}

/**
 * Copy text summary to clipboard
 */
export async function copyShareText(card: DecisionCard): Promise<boolean> {
  try {
    const text = generateShareText(card);
    await navigator.clipboard.writeText(text);
    return true;
  } catch (error) {
    console.error('Failed to copy text:', error);
    return false;
  }
}

// Helper functions
function roundRect(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  w: number,
  h: number,
  r: number
): void {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
}

function getTypeEmoji(type: string): string {
  const emojis: Record<string, string> = {
    PORTAL_DIRECT: '‚öñÔ∏è',
    PRICE_MATCH: 'üè∑Ô∏è',
    PRICE_DROP: 'üìâ',
    REDEEM_DECISION: 'üíé',
    ERASER_ITEM: 'üßπ',
    THIS_WEEK: 'üìÖ',
    CLAIM_KIT: 'üìã',
  };
  return emojis[type] || 'üìä';
}

function getConfidenceColor(confidence: ConfidenceLevel): string {
  const colors: Record<ConfidenceLevel, string> = {
    HIGH: '#059669',
    MED: '#f59e0b',
    LOW: '#ef4444',
  };
  return colors[confidence];
}

export default {
  generateShareCard,
  downloadShareCard,
  copyShareCardToClipboard,
  generateShareText,
  copyShareText,
};
